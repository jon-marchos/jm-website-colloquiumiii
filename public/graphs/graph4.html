<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>
<body>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    // Size of SVG
        var width = 0.9*window.innerWidth;
        var height = 0.9*window.innerHeight;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var colorScale = d3.scaleSequential(d3.interpolateRdYlGn);

d3.json("Neighborhoods_Editedv2.geojson").then(function(data) {
  var padding = 20;
  var projection = d3.geoMercator() // Change to Mercator for testing
                    .fitSize([width, height], data);
  
                    var path = d3.geoPath().projection(projection);

  var incomeValues = data.features.map(function(feature) {
    return feature.properties.averagemedianincome;
  });

  var incomeExtent = d3.extent(incomeValues);
  var incomeToColorValue = d3.scaleLinear()
                             .domain(incomeExtent)
                             .range([0, 1]);

  colorScale.domain([0, 1]);

  // Extract x and y values from the data
  var xValues = data.features.map(function(feature) {
    return feature.properties.foodstampratio;
  });

  var yValues = data.features.map(function(feature) {
    return feature.properties.supermarket_count;
  });


  // Create x and y scales based on the range of values
  var xScale = d3.scaleLinear()
                 .domain(d3.extent(xValues))
                 .range([padding, width - padding]);

  var yScale = d3.scaleLinear()
                 .domain(d3.extent(yValues))
                 .range([height - padding, padding]); // Reverse y-scale to match SVG coordinates

  // Create a scale for circle radius based on the range of average median income values
  var radiusScale = d3.scaleLinear()
                      .domain(d3.extent(incomeValues))
                      .range([10, 2]); // Adjust the range of radii as per your preference

data.features.forEach(function(feature) {
  var x = feature.properties.foodstampratio;
  var y = feature.properties.supermarket_count;
  var scatterplotRadius = radiusScale(feature.properties.averagemedianincome);
  drawDot(feature.geometry, xScale(x), yScale(y), scatterplotRadius, feature, projection);
});
});

function drawDot(polygon, scatterplotX, scatterplotY, scatterplotRadius, feature, projection) {
  var coordinates0 = polygon.coordinates[0].map(projection),
      coordinates1 = circle(coordinates0, scatterplotRadius, [scatterplotX, scatterplotY]),
      path = svg.append("path")
                .attr("d", "M" + coordinates1.join("L") + "Z")
                .attr("fill", function() {
                  const { NTAName, foodstampindex, physindex, economicindex } = feature.properties;
                  if (NTAName === "Harlem (North)") return "orange";
                  else if (NTAName === "Sunset Park (Central)") return "lime"; // Ensure whitespace is trimmed
                  else if (NTAName === "Spring Creek-Starrett City") return "red";
                  else if (foodstampindex === 0) return "lightgreen";
                  else if (foodstampindex === 1) return "yellow";
                  else if (foodstampindex === 2 && physindex === 0) return "lightgreen";
                  else if (foodstampindex === 2) return "pink";
                  else if (physindex === 2 && economicindex === 1) return "pink";
                  else return "green"; // Default color
                })
                .attr("stroke", "white");

  // Append a title for tooltip
  path.append("title")
      .text(function() {
        const { NTAName, foodstampindex, physindex, economicindex } = feature.properties;
        let status;
        if (["orange", "yellow"].includes(path.attr("fill"))) status = "Food Desert";
        else if (["lightgreen", "green"].includes(path.attr("fill"))) status = "Food Oasis";
        else if (["pink"].includes(path.attr("fill"))) status = "Food Desert";
        return `${NTAName}: ${status}`;
      });

  path.transition()
      .delay(1000)
      .duration(2000)
      .attr("d", "M" + coordinates0.join("L") + "Z");
}

function circle(coordinates, radius, centroid) {
  var circle = [],
      length = 0,
      lengths = [length],
      p0 = coordinates[0],
      p1,
      x,
      y,
      i = 0,
      n = coordinates.length;

  while (++i < n) {
    p1 = coordinates[i];
    x = p1[0] - p0[0];
    y = p1[1] - p0[1];
    lengths.push(length += Math.sqrt(x * x + y * y));
    p0 = p1;
  }

  var angleOffset = -Math.PI / 2,
      angle,
      i = -1,
      k = 2 * Math.PI / lengths[lengths.length - 1];

  while (++i < n) {
     angle = angleOffset + lengths[i] * k;
    circle.push([
      centroid[0] + radius * Math.cos(angle),
      centroid[1] + radius * Math.sin(angle)
    ]);
  }

  return circle;
}
</script>
</body>
